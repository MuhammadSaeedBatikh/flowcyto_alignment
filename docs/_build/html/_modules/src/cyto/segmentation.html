<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>src.cyto.segmentation &mdash; FLow Cytometry Alignment 1.0.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> FLow Cytometry Alignment
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"></div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">FLow Cytometry Alignment</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>src.cyto.segmentation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for src.cyto.segmentation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">skimage.segmentation</span> <span class="k">as</span> <span class="nn">sk_seg</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">threshold_multiotsu</span>
<span class="kn">import</span> <span class="nn">jenkspy</span>


<div class="viewcode-block" id="Gate"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Gate">[docs]</a><span class="k">class</span> <span class="nc">Gate</span><span class="p">:</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        This is an abstraction class for a flow cytometry 1-D gate.</span>

<span class="sd">        :param segment: :obj:`numpy.array(dtype=float)`, shape = [n, 1], An array containing original data (cells) of a particular segment/gate.</span>
<span class="sd">        :param t: :obj:`numpy.array(dtype=float)`, shape = [m, 1], An array that represents the x axis. (pdf represents the y axis)</span>
<span class="sd">        :param pd: :obj:`numpy.array(dtype=float)`, shape = [m, 1], An array which represents probability density function.</span>
<span class="sd">        :param gate: obj:`list`: open-ended gate location.</span>
<span class="sd">        :param tight_gate: :obj:`list`: tight gate location.</span>
<span class="sd">        :param sample_num: :obj:`int`: the sample number of which this gate belongs to.</span>
<span class="sd">        :param ch_num: :obj:`int`: the channel number of which this gate belongs to.</span>
<span class="sd">        :param gate_num_in_sample: obj:`int`, gate number in sample.</span>
<span class="sd">        :param overall_indx_in_data: obj:`int`, the overall index of a gate in the dataset.</span>
<span class="sd">        :ivar seg_min: :obj:`float`, minimum value in segment.</span>
<span class="sd">        :ivar seg_max: :obj:`float`, maximum value in segment.</span>
<span class="sd">        :ivar location_group: :obj:`int`, the location group number this gate belongs to.</span>
<span class="sd">        :ivar group_ref_score: :obj:`float`, the gate score as a reference for its own location group.</span>
<span class="sd">        :ivar morphology_group: :obj:`int`, the morphology group number this gate belongs to.</span>
<span class="sd">        :ivar is_location_reference: :obj:`Bool `, if :obj:`True`, the gate is the reference for its location group.</span>
<span class="sd">        :ivar aligned_flag: :obj:`int `, flag indicating alignment status.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">segment</span><span class="p">,</span>
                 <span class="n">t</span><span class="p">,</span><span class="n">pd</span><span class="p">,</span>
                 <span class="n">gate</span><span class="p">,</span>
                 <span class="n">tight_gate</span><span class="p">,</span>
                 <span class="n">sample_num</span><span class="p">,</span>
                 <span class="n">ch_num</span><span class="p">,</span>
                 <span class="n">gate_num_in_sample</span><span class="p">,</span>
                 <span class="n">overall_indx_in_data</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seg_min</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_max</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gate</span> <span class="o">=</span> <span class="n">gate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tight_gate</span> <span class="o">=</span> <span class="n">tight_gate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pd</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">pd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_num</span> <span class="o">=</span> <span class="n">sample_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ch_num</span> <span class="o">=</span> <span class="n">ch_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gate_num_in_sample</span> <span class="o">=</span> <span class="n">gate_num_in_sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overall_indx</span> <span class="o">=</span> <span class="n">overall_indx_in_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location_group</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_ref_score</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_location_reference</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># morphology_group is relative to location_group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">morphology_group</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aligned_flag</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="Gate.get_tightened_segment"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Gate.get_tightened_segment">[docs]</a>    <span class="k">def</span> <span class="nf">get_tightened_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Get data of segment within the input bounds. Default behaviour returns segment within original tightened bounds.</span>

<span class="sd">        :param a: :obj:`float`, start location.</span>
<span class="sd">        :param b: :obj:`float`, end location.</span>
<span class="sd">        :returns:</span>
<span class="sd">         - bounded_segment - :obj:`numpy.array`, 1-D array of data within the specified bound.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tight_gate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tight_gate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">&gt;=</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="o">&lt;</span><span class="n">b</span><span class="p">)</span>
        <span class="n">bounded_segment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bounded_segment</span></div>

<div class="viewcode-block" id="Gate.get_tight_gates"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Gate.get_tight_gates">[docs]</a>    <span class="k">def</span> <span class="nf">get_tight_gates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="o">=.</span><span class="mi">01</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">         Returns tight location of gate based on the provided quantile</span>

<span class="sd">        :param q: :obj:`float`, quantile value.</span>
<span class="sd">        :returns:</span>
<span class="sd">         - a - :obj:`float`, left boundary.</span>
<span class="sd">         - b - :obj:`float`, right boundary.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        A dunder method that checks whether two gates are equal based on sample number, channel number and segment&#39;s start and end.</span>

<span class="sd">        :param other: :obj:`Gate`,</span>
<span class="sd">        :returns:</span>
<span class="sd">         -  - :obj:`Bool`, returns :obj:`True` if self is equal to other.</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Gate</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_num</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">ch_num</span> <span class="ow">and</span>  \
                   <span class="bp">self</span><span class="o">.</span><span class="n">sample_num</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sample_num</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">gate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        A dunder method that checks whether two gates are not equal if sample number, channel number nor segment&#39;s start and end are not equal.</span>

<span class="sd">        :param other: :obj:`Gate`,</span>
<span class="sd">        :returns:</span>
<span class="sd">         -  - :obj:`Bool`, returns :obj:`True` if self is not equal to other.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        returns string representation of object.</span>

<span class="sd">        :return: :obj:`String`</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(Sample_num: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_num</span><span class="si">}</span><span class="s1">, Ch: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_num</span><span class="si">}</span><span class="s1">, Gate_num: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gate_num_in_sample</span><span class="si">}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span> \
            <span class="sa">f</span><span class="s1">&#39;Gate: [</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">1e3</span><span class="si">}</span><span class="s1">], Segment_min_max: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_min</span><span class="p">)</span><span class="o">/</span><span class="mf">1e3</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_max</span><span class="p">)</span><span class="o">/</span><span class="mf">1e3</span><span class="si">}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span>\
            <span class="sa">f</span><span class="s1">&#39;Location_group: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">location_group</span><span class="si">}</span><span class="s1">, Morphology_group: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">morphology_group</span><span class="si">}</span><span class="s1">, &#39;</span> \
            <span class="sa">f</span><span class="s1">&#39;Overall_Indx: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">overall_indx</span><span class="si">}</span><span class="s1">, Aligned_flag: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">aligned_flag</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>


<div class="viewcode-block" id="Sample"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample">[docs]</a><span class="k">class</span> <span class="nc">Sample</span><span class="p">:</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is an abstraction class for a flow cytometry sample. It houses the raw data and also allows several levels of manipulation</span>
<span class="sd">        such as having access to particular channel&#39;s data, its probability density function and so forth.</span>
<span class="sd">        A sample is comprised of a number of channels. Each channel consists of a number of gates/segments.</span>

<span class="sd">        :param data: :obj:`numpy.array(dtype=float)`, shape = [m, ch], A 2-D array containing the original data (rows = cells, columns = channels). m = number of cells, ch= number of channels.</span>
<span class="sd">        :param gates_per_channel: :obj:`numpy.array(dtype=int)`, shape = [ch, 1], A 1-D array containing the number of gates in each channel. A &#39;-1&#39; entery means unspecified (Automatic Segmentation).</span>
<span class="sd">        :param sample_num: :obj:`int`, sample number in dataset.</span>
<span class="sd">        :param gate_factor_q: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing quantile value for each channel.</span>
<span class="sd">        :param kde_window: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing Kernel Density Estimate window size for each channel. This determines how coarse or granular the estimated pdf is.</span>
<span class="sd">        :param area_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed AUC (ratio of cells) to be considered a proper segment/gate. Only required for watershed segmentation.</span>
<span class="sd">        :param width_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed width of the ravine between two segments/gates for the later to be considered a separate segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">        :param depth_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed depth of the ravine between two segments/gates for the later to be considered a separate segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">        :param verbose: :obj:`Bool`, if :obj:`True`, prints all information about all gates in each channel in sample.</span>
<span class="sd">        :ivar pdfs: :obj:`dict(list)`, a dictionary of the following pair [x, probability density functions] with channel number as its key.</span>
<span class="sd">        :ivar gates: :obj:`dict(list(Gate))`, a dictionary of lists of gates with channel number as its key.</span>
<span class="sd">        :ivar num_ch: :obj:`int`, number of channels.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">gates_per_channel</span><span class="p">,</span><span class="n">sample_num</span><span class="p">,</span> <span class="n">gate_factor_q</span><span class="o">=</span> <span class="mf">0.04</span><span class="p">,</span> <span class="n">area_threshold</span><span class="o">=.</span><span class="mi">005</span><span class="p">,</span>
                 <span class="n">kde_window</span><span class="o">=</span> <span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="n">width_threshold</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">depth_threshold</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span> <span class="kc">True</span><span class="p">):</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_num</span> <span class="o">=</span> <span class="n">sample_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_bounds_t</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tightened_gates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pdfs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">num_ch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gates_per_channel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ch</span> <span class="o">=</span> <span class="n">num_ch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gate_factor_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_ch</span><span class="p">)</span><span class="o">*</span><span class="n">gate_factor_q</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gate_factor_q</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">gate_factor_q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_ch</span><span class="p">)</span><span class="o">*</span><span class="n">area_threshold</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">area_threshold</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">area_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kde_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_ch</span><span class="p">)</span><span class="o">*</span><span class="n">kde_window</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kde_window</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">kde_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_ch</span><span class="p">)</span><span class="o">*</span><span class="n">width_threshold</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">width_threshold</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">width_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_ch</span><span class="p">)</span><span class="o">*</span><span class="n">depth_threshold</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">depth_threshold</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">else</span> <span class="n">depth_threshold</span>

        <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gates_per_channel</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resegment_ch</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

           <span class="c1"># z_t = data[:,i]</span>
           <span class="c1"># print(&#39;ch:&#39;,i)</span>
           <span class="c1">#</span>
           <span class="c1"># kde = sns._statistics.KDE(bw_method=self.kde_window[i])</span>
           <span class="c1"># pd, t = kde(x1=z_t.flatten())</span>
           <span class="c1"># self.pdfs[i] = [t, pd]</span>
           <span class="c1">#</span>
           <span class="c1"># if n!=-1:</span>
           <span class="c1">#     if n&gt;1:</span>
           <span class="c1">#         # bounds_t = segment_func(z_t, method=&#39;otsu&#39;, num_segments=n)</span>
           <span class="c1">#         bounds_t,t,pd = segment_func(z_t, method=&#39;je&#39;, num_segments=n)</span>
           <span class="c1">#     else:</span>
           <span class="c1">#         bounds_t,t,pd = [z_t.min(), z_t.max()]</span>
           <span class="c1"># else:</span>
           <span class="c1">#</span>
           <span class="c1">#     bounds_t = segment_func(z_t, method=&#39;water&#39;, kde_window= self.kde_window[i],</span>
           <span class="c1">#                        area_threshold=self.area_threshold[i],</span>
           <span class="c1">#                        width_threshold=self.width_threshold[i],</span>
           <span class="c1">#                        depth_threshold =self.depth_threshold[i])</span>
           <span class="c1">#</span>
           <span class="c1"># bounds_t = convert_watershed_lines_to_gate(bounds_t)</span>
           <span class="c1"># self.all_bounds_t[i] = bounds_t</span>
           <span class="c1"># print(&#39;bounds&#39;, bounds_t)</span>
           <span class="c1"># tightened_bounds = tighten_all_gates(z_t.reshape(-1,1), bounds_t, gate_factor_q[i])</span>
           <span class="c1"># print(&#39;tightened_bounds&#39;, tightened_bounds)</span>
           <span class="c1"># for k, b in enumerate(bounds_t):</span>
           <span class="c1">#      ind = np.logical_and(z_t&gt;=b[0],</span>
           <span class="c1">#                                   z_t&lt;b[1])</span>
           <span class="c1">#      seg = z_t[ind]</span>
           <span class="c1">#      gate_obj  = Gate(seg, t,pd,</span>
           <span class="c1">#                       gate=b,</span>
           <span class="c1">#                       tight_gate=tightened_bounds[k],</span>
           <span class="c1">#                             sample_num=sample_num,</span>
           <span class="c1">#                       ch_num=i,</span>
           <span class="c1">#                       gate_num_in_sample=k)</span>
           <span class="c1">#      if self.gates.get(i):</span>
           <span class="c1">#         self.gates[i] += [gate_obj]</span>
           <span class="c1">#      else:</span>
           <span class="c1">#         self.gates[i] =  [gate_obj]</span>


<div class="viewcode-block" id="Sample.resegment_ch"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.resegment_ch">[docs]</a>    <span class="k">def</span> <span class="nf">resegment_ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">kde_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">area_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">depth_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Resegments channel based on new threshold values.</span>

<span class="sd">        :param ch: :obj:`int`, channel number.</span>
<span class="sd">        :param kde_window: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing Kernel Density Estimate window size for each channel. This determines how coarse or granular the estimated pdf is.</span>
<span class="sd">        :param area_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed AUC (ratio of cells) to be considered a proper segment/gate. Only required for watershed segmentation.</span>
<span class="sd">        :param width_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed width of the ravine between two segments/gates for the later to be considered a separate segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">        :param depth_threshold: :obj:`numpy.array(dtype=float)`, shape = [ch, 1], A 1-D array containing the minimum allowed depth of the ravine between two segments/gates for the later to be considered a separate segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">        :param init: :obj:`Bool`, if :obj:`True`, recomputes probability density function.</span>
<span class="sd">        :param verbose: :obj:`Bool`, if :obj:`True`, prints all information about all gates in each channel in sample.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">init</span> <span class="ow">and</span> <span class="n">kde_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">area_threshold</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">depth_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">if</span> <span class="n">area_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">area_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">if</span> <span class="n">width_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">width_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">if</span> <span class="n">depth_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">depth_threshold</span>

        <span class="n">z_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">ch</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kde_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">init</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdfs</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">init</span> <span class="ow">or</span> <span class="n">kde_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kde_window</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kde_window</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">if</span> <span class="n">kde_window</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kde_window</span>

            <span class="n">kde</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">_statistics</span><span class="o">.</span><span class="n">KDE</span><span class="p">(</span><span class="n">bw_method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kde_window</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>
            <span class="n">pdf</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">kde</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="n">z_t</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdfs</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="p">]</span>

        <span class="n">bounds_t</span> <span class="o">=</span> <span class="n">segment_func</span><span class="p">(</span><span class="n">z_t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;water&#39;</span><span class="p">,</span>
                                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="n">pdf</span><span class="p">,</span>
                                <span class="n">area_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span>
                                <span class="n">width_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">width_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span>
                                <span class="n">depth_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depth_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span>
                                <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
                                <span class="p">)</span>
        <span class="n">bounds_t</span> <span class="o">=</span> <span class="n">convert_watershed_lines_to_gate</span><span class="p">(</span><span class="n">bounds_t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_bounds_t</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds_t</span>
        <span class="n">tightened_bounds</span> <span class="o">=</span> <span class="n">tighten_all_gates</span><span class="p">(</span><span class="n">z_t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">bounds_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gate_factor_q</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">width_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth_threshold</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="n">bounds_t</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;tightened_bounds&#39;</span><span class="p">,</span> <span class="n">tightened_bounds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds_t</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">z_t</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">z_t</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">z_t</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">gate_obj</span> <span class="o">=</span> <span class="n">Gate</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pdf</span><span class="p">,</span>
                            <span class="n">gate</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
                            <span class="n">tight_gate</span><span class="o">=</span><span class="n">tightened_bounds</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                            <span class="n">sample_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_num</span><span class="p">,</span>
                            <span class="n">ch_num</span><span class="o">=</span><span class="n">ch</span><span class="p">,</span>
                            <span class="n">gate_num_in_sample</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">gate_obj</span><span class="p">]</span></div>


<div class="viewcode-block" id="Sample.tighten_gates_in_a_channel"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.tighten_gates_in_a_channel">[docs]</a>    <span class="k">def</span> <span class="nf">tighten_gates_in_a_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">gate_factor_q</span><span class="p">):</span>

            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                Updates the tight gate location for gates of a particular channels based on the provided quantile.</span>

<span class="sd">                :param ch: :obj:`int`, channel number.</span>
<span class="sd">                :param gate_factor_q: :obj:`float`, quantile value.</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="n">z_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">ch</span><span class="p">]</span>
            <span class="n">tightened_bounds</span> <span class="o">=</span> <span class="n">tighten_all_gates</span><span class="p">(</span><span class="n">z_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_bounds_t</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="n">gate_factor_q</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tightened_bounds</span><span class="p">):</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">ch</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tight_gate</span> <span class="o">=</span> <span class="n">b</span></div>


<div class="viewcode-block" id="Sample.tighten_all_gates"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.tighten_all_gates">[docs]</a>    <span class="k">def</span> <span class="nf">tighten_all_gates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gate_factor_q</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Updates the tight gate location for a all channels based on the provided quantile.</span>

<span class="sd">            :param gate_factor_q: :obj:`float`, quantile value.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_num</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tighten_gates_in_a_channel</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">gate_factor_q</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sample.update_gate"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.update_gate">[docs]</a>    <span class="k">def</span> <span class="nf">update_gate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">          Updates the status of only the gate according to channel number and index with the provided flag.</span>

<span class="sd">          :param channel: :obj:`int`, channel number.</span>
<span class="sd">          :param index: :obj:`int`, gate index.</span>
<span class="sd">          :param flag: :obj:`int`, alignment flag.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">aligned_flag</span> <span class="o">=</span> <span class="n">flag</span></div>

<div class="viewcode-block" id="Sample.update_channel_gates"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.update_channel_gates">[docs]</a>    <span class="k">def</span> <span class="nf">update_channel_gates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">          Updates the status of all gates in the provided channel with the provided flag.</span>

<span class="sd">          :param channel: :obj:`int`, channel number.</span>
<span class="sd">          :param flag: :obj:`int`, alignment flag.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">gate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
            <span class="n">gate</span><span class="o">.</span><span class="n">aligned_flag</span> <span class="o">=</span> <span class="n">flag</span></div>




<div class="viewcode-block" id="Sample.check_if_still_non_aligned"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.check_if_still_non_aligned">[docs]</a>    <span class="k">def</span> <span class="nf">check_if_still_non_aligned</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Checks whether all gates in the provided channel have been aligned or not.</span>

<span class="sd">        :param channel: :obj:`int`, channel number.</span>
<span class="sd">        :return: :obj:`Bool`.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">|</span> <span class="o">~</span> <span class="n">g</span><span class="o">.</span><span class="n">aligned_flag</span>
        <span class="k">return</span> <span class="n">b</span></div>

<div class="viewcode-block" id="Sample.get_ch_alignment_status"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.Sample.get_ch_alignment_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_ch_alignment_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        Check whether all gates in channel have been aligned or not.</span>

<span class="sd">        :param channel: :obj:`int`, channel number.</span>
<span class="sd">        :return: :obj:`Bool`.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">channel</span><span class="p">]:</span>
            <span class="n">b</span><span class="o">+=</span><span class="n">g</span><span class="o">.</span><span class="n">aligned_flag</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gates</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span></div>


    <span class="c1"># def revert_min_max_normalization(self, maxes, mins):</span>
    <span class="c1">#     for ch, _ in enumerate(maxes):</span>
    <span class="c1">#         self.data[:,ch] = self.data[:,ch]*(maxes[ch]-mins[ch]) + mins[ch]</span>
    <span class="c1">#</span>
    <span class="c1">#     for ch, value in self.gates.items():</span>
    <span class="c1">#         for gate in value:</span>
    <span class="c1">#             a,b = (maxes[ch]-mins[ch]),  mins[ch]</span>
    <span class="c1">#             gate[1] = [ g*a + b for g in gate[1]]</span>
    <span class="c1">#     return self</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">ch</span><span class="p">]</span></div>


<div class="viewcode-block" id="non_maximum_suppression"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.non_maximum_suppression">[docs]</a><span class="k">def</span> <span class="nf">non_maximum_suppression</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">seg_pdf</span><span class="p">,</span> <span class="n">area_threshold</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Performs non-maximum suppression on segments that do not surpass the provided area-under-the-curve (AUC) threshold.</span>

<span class="sd">    :param pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which represents probability density function.</span>
<span class="sd">    :param seg_pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains segment labels for each point in the provided pdf.</span>
<span class="sd">    :param area_threshold: :obj:`float`: the minimum allowed AUC (ratio of cells) to be considered a proper segment/gate.</span>
<span class="sd">    :return: :obj:`numpy.array(dtype=int)`, shape = [m, 1], masked segments with zeros in place of the original suppressed segments.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">seg_mask</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">):</span>
        <span class="c1"># compute the normalized AUC using trapezoid method.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">seg_mask</span><span class="o">==</span><span class="n">s</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
        <span class="c1"># suppress if r is less than threshold or the segment has less than 2 elements.</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span><span class="n">area_threshold</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">seg_mask</span><span class="o">==</span><span class="n">s</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">seg_mask</span><span class="p">[</span><span class="n">seg_mask</span><span class="o">==</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">seg_mask</span></div>


<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Assign each point in segments of seg_pdf that has been suppressed (i.e. zeroed)  to the closest segment.</span>

<span class="sd">    :param seg_pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains segment labels for each point in pdf.</span>
<span class="sd">    :return: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains newly assigned segment labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)]])</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">seg_pdf</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">seg_pdf</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">arr</span><span class="p">[:</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">seg_pdf</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">seg_pdf</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">seg_pdf</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a_ind</span><span class="p">,</span> <span class="n">b_ind</span><span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">m_ind</span> <span class="o">=</span> <span class="n">a_ind</span> <span class="o">+</span> <span class="p">(</span><span class="n">b_ind</span><span class="o">-</span><span class="n">a_ind</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">a_ind</span><span class="p">:</span><span class="n">m_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">m_ind</span><span class="p">:</span> <span class="n">b_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">arr</span></div>


<div class="viewcode-block" id="suppress_and_merge_tiny_basins"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.suppress_and_merge_tiny_basins">[docs]</a><span class="k">def</span> <span class="nf">suppress_and_merge_tiny_basins</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">seg_pdf</span><span class="p">,</span> <span class="n">width_threshold</span><span class="p">,</span> <span class="n">depth_threshold</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Suppresses and merges tiny basins/gates/segments depending on the width and depth of the ravine between them.</span>

<span class="sd">    :param pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which represents probability density function.</span>
<span class="sd">    :param seg_pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains segment labels for each point in the provided pdf.</span>
<span class="sd">    :param width_threshold: :obj:`float`: the minimum allowed width of the ravine between two segments/gates for the later to be considered a separate  segment or an extension of the previous segment.</span>
<span class="sd">    :param depth_threshold: :obj:`float`: the minimum allowed depth of the ravine between two segments/gates for the later to be considered a separate  segment or an extension of the previous segment.</span>
<span class="sd">    :param verbose: :obj:`Bool`, if :obj:`true`, prints width and depth values and whether they are suppressed or not.</span>
<span class="sd">    :return: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains newly assigned segment labels.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># There may be a bug in this method that needs fixing.</span>
    <span class="c1"># a possible improvement is to merge segments using agglomerative clustering</span>

    <span class="n">new_seg_mask</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="n">watershed_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">seg_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="n">merge_map</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_labels</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_labels</span><span class="p">)):</span>
        <span class="n">curr_seg</span><span class="p">,</span> <span class="n">prev_seg</span><span class="o">=</span> <span class="n">seg_labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">seg_labels</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">curr_ind</span><span class="p">,</span> <span class="n">prev_ind</span> <span class="o">=</span> <span class="n">seg_pdf</span><span class="o">==</span><span class="n">curr_seg</span><span class="p">,</span> <span class="n">seg_pdf</span><span class="o">==</span><span class="n">prev_seg</span>
        <span class="n">curr_max</span><span class="p">,</span> <span class="n">prev_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">curr_ind</span><span class="p">])</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">curr_ind</span><span class="p">),</span>\
                             <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">prev_ind</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">prev_ind</span><span class="p">)</span>
        <span class="n">dist_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">curr_max</span> <span class="o">-</span> <span class="n">prev_max</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">width_threshold</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="n">curr_max</span><span class="p">],</span> <span class="n">pdf</span><span class="p">[</span><span class="n">prev_max</span><span class="p">])</span> <span class="o">-</span> <span class="n">pdf</span><span class="p">[</span><span class="n">watershed_lines</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">/</span><span class="n">pdf</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;width&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">curr_max</span> <span class="o">-</span> <span class="n">prev_max</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">),</span> <span class="s1">&#39;depth&#39;</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span>
                  <span class="s1">&#39;width_cond&#39;</span><span class="p">,</span> <span class="n">dist_cond</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">depth_threshold</span> <span class="ow">or</span> <span class="n">dist_cond</span><span class="p">:</span>
            <span class="n">merge_map</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">start_seg</span> <span class="o">=</span> <span class="n">seg_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">merge_map</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">seg_labels</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">new_seg_mask</span><span class="p">[</span><span class="n">new_seg_mask</span><span class="o">==</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_seg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_seg</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">new_seg_mask</span></div>


<div class="viewcode-block" id="get_watershed_lines_from_labeled_segs"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.get_watershed_lines_from_labeled_segs">[docs]</a><span class="k">def</span> <span class="nf">get_watershed_lines_from_labeled_segs</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Gets watershed lines locations from segmented probability density function.</span>

<span class="sd">    :param seg_pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which contains segment labels for each point in the provided pdf.</span>
<span class="sd">    :param x: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array that represents the x axis. (seg_pdf represents the y axis)</span>
<span class="sd">    :return gates: :obj:`list`, a list with its entries as the boundaries of each gate</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ind</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_pdf</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">watershed_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">watershed_lines</span></div>


<div class="viewcode-block" id="tighten_all_gates"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.tighten_all_gates">[docs]</a><span class="k">def</span> <span class="nf">tighten_all_gates</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">gates</span><span class="p">,</span> <span class="n">gate_q_factor</span> <span class="o">=</span> <span class="o">.</span><span class="mi">01</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Tightens all gates location based on the provided quantile.</span>

<span class="sd">    :param z: :obj:`numpy.array(dtype=float)`, shape = [n, 1], An array which contains original data (cells).</span>
<span class="sd">    :param gates: :obj:`list`, :obj:`len(gates) = m` where m is the number of gates.</span>
<span class="sd">    :param gate_q_factor: :obj:`float`, tightening the gates using quantiles.</span>
<span class="sd">    :return: modified_gates :obj:`list`, :obj:`len(gates) = m` where m is the number of gates.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">modified_gates</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gates</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gates</span><span class="p">):</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span> <span class="n">z</span><span class="o">&gt;=</span><span class="n">gate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="o">&lt;=</span><span class="n">gate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">gate_q_factor</span><span class="p">)</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="mi">1</span><span class="o">-</span><span class="n">gate_q_factor</span><span class="p">)</span>
        <span class="n">gate_a</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span>
        <span class="n">gate_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q0</span>
        <span class="n">gate_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q1</span>
        <span class="n">modified_gates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gate_a</span>
    <span class="k">return</span> <span class="n">modified_gates</span></div>


<div class="viewcode-block" id="convert_watershed_lines_to_gate"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.convert_watershed_lines_to_gate">[docs]</a><span class="k">def</span> <span class="nf">convert_watershed_lines_to_gate</span><span class="p">(</span><span class="n">watershed_lines</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Given watershed lines such as [0, 0.5, 1], this method returns the following list of gates [[0,.5], [.5,1]].</span>

<span class="sd">    :param watershed_lines: :obj:`list`, :obj:`len(bounds) = m` where m is the number of watershed lines.</span>
<span class="sd">    :return gates: :obj:`list(list)`, :obj:`len(gates) = m-1` where m is the number of gates.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">gates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">watershed_lines</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">watershed_lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">watershed_lines</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">gates</span> <span class="o">+=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">gates</span></div>


<div class="viewcode-block" id="convert_gates_to_watershed_lines"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.convert_gates_to_watershed_lines">[docs]</a><span class="k">def</span> <span class="nf">convert_gates_to_watershed_lines</span><span class="p">(</span><span class="n">gates</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Given a list of gates such as [[0,.5], [.5,1]] this method returns the following list of watershed lines [0, 0.5, 1].</span>

<span class="sd">    :param gates: :obj:`list(list)`, :obj:`len(gates) = m` where m is the number of gates.</span>
<span class="sd">    :return watershed_lines: :obj:`list`, :obj:`len(watershed_lines) = m+1` where m is the number of watershed lines.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">watershed_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gates</span><span class="p">)):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">gates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">watershed_lines</span> <span class="o">+=</span> <span class="n">g</span>
    <span class="n">watershed_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">gates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">watershed_lines</span></div>


<div class="viewcode-block" id="segment_func"><a class="viewcode-back" href="../../../segmentation.html#src.cyto.segmentation.segment_func">[docs]</a><span class="k">def</span> <span class="nf">segment_func</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;water&#39;</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="o">=.</span><span class="mi">005</span><span class="p">,</span>
            <span class="n">width_threshold</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">depth_threshold</span><span class="o">=.</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">num_segments</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This method performs segmentation on a raw vector of cells.</span>

<span class="sd">    :param z: :obj:`numpy.array(dtype=float)`, shape = [n, 1], An array which contains original data (cells).</span>
<span class="sd">    :param method: :obj:`str`: defines segmentation method, [&#39;watershed&#39;, &#39;otsu&#39;, &#39;jenkis&#39;].</span>
<span class="sd">    :param x: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array that represents the x axis where pdf represents the y axis. (Only required for watershed segmentation.)</span>
<span class="sd">    :param pdf: :obj:`numpy.array(dtype=int)`, shape = [m, 1], An array which represents the probability density function. (Only required for watershed segmentation.)</span>
<span class="sd">    :param area_threshold: :obj:`float`: the minimum allowed AUC (ratio of cells) to be considered a proper segment/gate. (Only required for watershed segmentation.)</span>
<span class="sd">    :param width_threshold: :obj:`float`: the minimum allowed width of the ravine between two segments/gates for the later to be considered a separate  segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">    :param depth_threshold: :obj:`float`: the minimum allowed depth of the ravine between two segments/gates for the later to be considered a separate  segment or an extension of the previous segment. Only required for watershed segmentation.</span>
<span class="sd">    :param num_segments: :obj:`int`: number of segments. Only required for Otsu and Jenkis.</span>
<span class="sd">    :param verbose: :obj:`Bool`, if :obj:`true`, prints each gate area, width and depth values and whether they are suppressed or not.</span>
<span class="sd">    :returns:</span>
<span class="sd">        - watershed_lines - :obj:`list`, :obj:`len(bounds) = m+1`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;otsu&#39;</span><span class="p">:</span>
        <span class="n">watershed_lines</span> <span class="o">=</span> <span class="n">threshold_multiotsu</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_segments</span><span class="p">),</span> <span class="mi">128</span><span class="p">)</span>
        <span class="n">watershed_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">()],</span><span class="n">watershed_lines</span><span class="p">,[</span><span class="n">z</span><span class="o">.</span><span class="n">max</span><span class="p">()]])</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;je&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jenkis&#39;</span><span class="p">:</span>
        <span class="c1"># subsample</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10000</span><span class="p">))</span>
        <span class="n">watershed_lines</span> <span class="o">=</span> <span class="n">jenkspy</span><span class="o">.</span><span class="n">jenks_breaks</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span><span class="nb">int</span><span class="p">(</span><span class="n">num_segments</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;water&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;watershed&#39;</span><span class="p">:</span>
        <span class="c1"># flip and segment</span>
        <span class="n">pd_a_s</span> <span class="o">=</span> <span class="n">sk_seg</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">pdf</span><span class="p">)</span>
        <span class="c1"># apply non-maximum suppression on area</span>
        <span class="n">pd_a_s</span> <span class="o">=</span>  <span class="n">non_maximum_suppression</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">pd_a_s</span><span class="p">,</span> <span class="n">area_threshold</span> <span class="o">=</span> <span class="n">area_threshold</span><span class="p">)</span>
        <span class="c1"># merge suppressed segments</span>
        <span class="n">pd_a_s</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">pd_a_s</span><span class="p">)</span>
        <span class="c1"># suppress and merge segments with tiny ravines between them.</span>
        <span class="n">pd_a_s</span> <span class="o">=</span> <span class="n">suppress_and_merge_tiny_basins</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span> <span class="n">pd_a_s</span><span class="p">,</span> <span class="n">width_threshold</span><span class="p">,</span> <span class="n">depth_threshold</span><span class="p">,</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1"># make segments starts from 0.</span>
        <span class="n">pd_a_s</span> <span class="o">-=</span><span class="n">pd_a_s</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">watershed_lines</span> <span class="o">=</span> <span class="n">get_watershed_lines_from_labeled_segs</span><span class="p">(</span><span class="n">pd_a_s</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">watershed_lines</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Muhammad Saeed.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>